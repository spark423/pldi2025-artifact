/*This is the template for the expf function generated using the rounding-invariant outputs approach. */

#include "mathhelper.h"

double ourlibm_expf_rz(float x) {
  float_x fx = {.f=x};
  if((fx.x & 0x7FFFFFFF) == 0) return 1.0;
  if(fx.x <= 0x33ffffff) {
    if(fx.x <= 0x337fffff) return 0x1.0000008p+0;
    return 0x1.0000018p+0;
  }
  if(fx.x >= 0x42b17218 && fx.x <= 0xb3800000) {
    if(fx.x < 0x80000000) {
      if(fx.x < 0x7f800000) return 0x1.ffffff8p+127;
      if(fx.x == 0x7f800000) return 1.0/0.0;
      return 0.0/0.0;
    }
    if(fx.x <= 0xb3000000) return 0x1.ffffff8p-1;
    return 0x1.fffffe8p-1;
  }
  if(fx.x >= 0xc2cff1b5) {
    if(fx.x == 0xff800000) return 0.0;
    if(fx.x < 0xff800000) return 0x1p-151;
    else return 0.0/0.0;
  }

  double xp = x*LGEX64; 
  int N = (int)xp;
  int N2 = N % 64;
  if(N2<0) N2 += 64;
  int N1 = N-N2;
  int M = N1/64;
  int J = N2;
  double R = __builtin_fma(-N, ONEBY64LGE, x);
  double y = 0.0;
  if (R < -0x1.9e76cap-24) {
      /* The contents of exp_ri_outputs_p1 go here */
      double coeffs[5] = {// Add the coeffecients of the final polynomial here, from lowest term to higheset */};
      double R2 = rz_multiply(R, R);
      double tmp1 = rz_add(rz_multiply(R, coeffs[1]), coeffs[0]);
      double tmp2 = rz_add(rz_multiply(R, coeffs[3]), coeffs[2]);
      double tmp3 = rz_add(rz_multiply(R2, coeffs[4]), tmp2);
      double tmp4 = rz_multiply(R2, tmp3);
      y = rz_add(tmp4, tmp1);
  } else {
      /* The contents of exp_ri_outputs_p2 go here */
      double coeffs[5] = {// Add the coeffecients of the final polynomial here, from lowest term to higheset */};
      double R2 = rz_multiply(R, R);
      double tmp1 = rz_add(rz_multiply(R, coeffs[1]), coeffs[0]);
      double tmp2 = rz_add(rz_multiply(R, coeffs[3]), coeffs[2]);
      double tmp3 = rz_add(rz_multiply(R2, coeffs[4]), tmp2);
      double tmp4 = rz_multiply(R2, tmp3);
      y = rz_add(tmp4, tmp1);
  }
  double_x ret = {.d=exp2JBy64[J]};
  ret.x += ((uint64_t)M << 52);
  y = rz_multiply(y, ret.d);
  return y;
}
